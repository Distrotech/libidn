#!/usr/bin/perl

# Author: Thomas Jacob, Internet24.de

# Copyright (C) 2004  Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

# Use this to generate custom TLD restriction structures as well
#  like follows "./gen-tld-tables TLD definition-file"

# I consider the output of this program to be unrestricted.  Use it as
# you will.
#

use strict;
use warnings;

my $SPEC_DIR="../doc/tld";
if ($#ARGV>=0 && $ARGV[0] =~ m/^DIR=(.+)$/)
{
	$SPEC_DIR = $1;
	shift @ARGV;
}

my $DOMAINS_PATH = "$SPEC_DIR/defs";
my $TEMPLATE_PATH = "$SPEC_DIR/templates";
my $OUTPUT_FILE = "tldchk-data.c";
my $HEADER=<<EOT;
/* This file is automatically generated.  DO NOT EDIT!
   Instead, rerun gen-tld-tables.pl. */

#include <tldchk.h>
EOT

# Custom run.
if (@ARGV)
{
	my $tld = lc(shift @ARGV);
	my $filename = shift @ARGV;

	my $vermaj = 0;
	my $vermin = 0;
	
	my $data = process_definition("$filename", \$vermaj, \$vermin);

	my @singles;
	my @intervals;

	die "No data processed\n" unless $data;
	
	optimize($data);

	foreach(@$data)
	{
		if ($_->[0] == $_->[1])
		{
			push @singles, $_->[0];
		}
		else
		{
			push @intervals, $_;
		}
	}

	print STDOUT $HEADER;
	print_tld_domain(\*STDOUT, $tld, \@singles, \@intervals, $vermaj, $vermin);
}
else # Default run.
{

	open(F, ">$OUTPUT_FILE");

	print F $HEADER;

	my @tlds;
	opendir(DIR, $DOMAINS_PATH) or die "Couldn't open dir $DOMAINS_PATH\n";
	my @files = sort grep { !/^\./ && -d "$DOMAINS_PATH/$_" } readdir(DIR);
	closedir(DIR);
	foreach my $tld (@files)
	{
		my $vermaj = 0;
		my $vermin = 0;
		my $data = process_definition("$DOMAINS_PATH/$tld/def", \$vermaj, \$vermin);

		next unless $data;
		push @tlds, $tld;
		
		my @singles;
		my @intervals;

		optimize($data);

		foreach(@$data)
		{
			if ($_->[0] == $_->[1])
			{
				push @singles, $_->[0];
			}
			else
			{
				push @intervals, $_;
			}
		}

		$tld = lc($tld);

		print_tld_domain(\*F, $tld, \@singles, \@intervals, $vermaj, $vermin);
	}
	closedir(DIR);

	print F "\n\n";
	print F "/* Main array */\n\n";
	print F "const TLDCHK_domain * tldchk_domains[] =\n";
	print F "{\n";
	foreach (@tlds)
	{
		print F " &__${_}_domain,\n";
	}
	print F " 0\n";
	print F "};\n";
	close(F);
}

# Print tld domain structure.
# void print_tld_domain(\*FILE, $tld, \@singles, \@intervals, $vermaj, $vermin);
sub print_tld_domain
{
	my $fh = shift;
	my $tld = shift;
	my $singles =  shift;
	my $intervals = shift;
	my $vermaj = shift;
	my $vermin = shift;

	print $fh "\n\n";
	print $fh "/* TLD $tld */\n\n";
	print $fh "const uint32_t __${tld}_singles[] =\n";
	print $fh "{\n";

	my $num_singles = @$singles;
	if (@$singles)
	{
		my $last = pop @$singles;
		foreach (@$singles)
		{
			print $fh " $_,\n";
		}
		print $fh " $last\n";
	}
	print $fh "};\n\n";

	print $fh "const uint32_t __${tld}_intervals[] =\n";
	print $fh "{\n";

	my $num_intervals = @$intervals;
	if (@$intervals)
	{
		my $last = pop @$intervals;
		foreach (@$intervals)
		{
			print $fh " $_->[0],  $_->[1],\n";
		}
		print $fh " $last->[0],  $last->[1]\n";
	}
	print $fh "};\n\n";
	
	print $fh "const TLDCHK_domain __${tld}_domain =\n";
	print $fh "{\n";
	print $fh " \"$tld\",\n";
	print $fh " $vermaj,\n";
	print $fh " $vermin, \n";
	print $fh " $num_singles,\n";
	print $fh " $num_intervals,\n";
	print $fh " __${tld}_singles,\n";
	print $fh " __${tld}_intervals\n";
	print $fh "};\n";
}

# process a definition file
# $filename, \$vermaj, \$vermin
# return @data on success, undef otherwise
sub process_definition
{
	my $filename = shift;
	my $vermaj = shift;
	my $vermin = shift;
	my @data;

	local * FILE;

	if(!open(FILE, "<$filename"))
	{
		print "Can't open $filename.\n";
		return undef;
	}

	my ($is_int,$have_num,$num,$cnum);
	my $line = 1;
	while(<FILE>)
	{
		chomp;

		if (m/^#include\s+(\S+)\s*$/i)
		{
			my $incfile = $1;
			$incfile =~ s/^\@template\:/$TEMPLATE_PATH\//i;
			my ($d1, $d2);
			my $incdata = process_definition($incfile, \$d1, \$d2);
			if ($incdata)
			{
				push @data,@$incdata;
				next;
			}
			else
			{
				return undef;
			}
		}
		if (m/^#version (\d+)\.(\d+)$/)
		{
			$$vermaj = $1;
			$$vermin = $2;
			next;
		}
		s/#.*$//;

		while ($_ ne "")
		{
			s/^\s*//;
			if ( (s/^(0x)([a-f0-9]+)//i) || (s/^(0)(\d+)//) || (s/^(\d+)//) )
			{
				$cnum = $1;
				if ((lc($1) eq "0x") && $2)
				{
					$cnum = hex($2);
				}
				elsif (($1 eq "0") && $2)
				{
					$cnum = oct($2);
				}

				if ($have_num)
				{
					if ($is_int)
					{
						push @data, [$num, $cnum];
						$have_num = 0;
						$is_int = 0;
					}
					else
					{
						push @data, [$num,$num];
						$num = $cnum;
					}
				}
				else
				{
					$have_num = 1;
					$num = $cnum;
				}
			}
			elsif (s/^\-//)
			{
				$is_int = 1;
			}
			else
			{
				die "Parser error in file $filename".
				    " at line $line near $_, " if $_ ne "";
			}
		}
		$line++;
	}
	close(FILE);
	if ($have_num)
	{
		if ($is_int)
		{
			push @data, [$num, $cnum];
		}
		else
		{
			push @data, [$num, $num];
		}
	}
	return \@data;
}

# Build minimal set of intervals.
# void optimize(\@intervals)
sub optimize
{
	my $intervals = shift;

	return undef unless (@$intervals);

	my @intervals = sort {$a->[0] <=> $b->[0]} @$intervals;
	@$intervals = ();

	my $cur_int = shift @intervals;

	foreach (@intervals)
	{
		if ($_->[0]>($cur_int->[1]+1))
		{
			push @$intervals, $cur_int;
			$cur_int = $_;
		}
		else
		{
			if ($_->[1] > $cur_int->[1])
			{
				$cur_int->[1] = $_->[1];
			}
		}
	}
	push @$intervals, $cur_int;
}
